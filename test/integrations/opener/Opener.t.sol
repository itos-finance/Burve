// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.27;
import {BurveForkableTest} from "../Fork.u.sol";
import {Opener} from "../../../src/integrations/opener/Opener.sol";
import {MAX_TOKENS} from "../../../src/multi/Constants.sol";
import {IERC20} from "openzeppelin-contracts/token/ERC20/IERC20.sol";
import {console2} from "forge-std/console2.sol";
import {Create2Deployer} from "../../utils/Create2Deployer.sol";
import {IOBRouter} from "../../../src/integrations/opener/IOBRouter.sol";
import {FullMath} from "../../../src/FullMath.sol";

contract TestOpener is BurveForkableTest {
    Opener opener;
    Create2Deployer create2Deployer;
    bytes32 internal constant OPENER_SALT = keccak256("opener-test-salt");

    function deployOpenerDeterministically() internal returns (Opener) {
        if (address(create2Deployer) == address(0)) {
            create2Deployer = new Create2Deployer();
        }
        bytes memory bytecode = abi.encodePacked(
            type(Opener).creationCode,
            abi.encode(0xFd88aD4849BA0F729D6fF4bC27Ff948Ab1Ac3dE7)
        );
        address addr = create2Deployer.deploy(bytecode, OPENER_SALT);
        return Opener(addr);
    }

    function testTwoTokenOpener() public forkOnly {
        opener = deployOpenerDeterministically();

        // note these inputs and params info must be generated by the swap.mjs file.
        address inputToken = address(
            0x0555E30da8f98308EdB960aa94C0Db47230d2B9c
        );
        uint256 inputAmount = 100000000;
        address outputToken = address(
            0x541FD749419CA806a8bc7da8ac23D346f2dF8B77
        );
        uint256 outputQuote = 999779754633815246;
        uint256 outputMin = 989781957087477093;
        address outputReceiver = address(
            0xed63E871F5de87cb1919671eE9e2d331183Eda8f
        );

        deal(inputToken, address(this), 5e18);
        IERC20(inputToken).approve(address(opener), 5e18);

        IOBRouter.swapTokenInfo memory info = IOBRouter.swapTokenInfo({
            inputToken: inputToken,
            inputAmount: inputAmount,
            outputToken: outputToken,
            outputQuote: outputQuote,
            outputMin: outputMin,
            outputReceiver: outputReceiver
        });

        bytes[MAX_TOKENS] memory params;
        params[1] = abi.encodeWithSelector(
            IOBRouter.swap.selector,
            info,
            hex"541FD749419CA806a8bc7da8ac23D346f2dF8B77010000000000000000000000000000000000000000000000000ddfee63c89364ce00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db54e0a597c5300010555E30da8f98308EdB960aa94C0Db47230d2B9c01ffff09BE09E71BDc7b8a50A05F7291920590505e3C7744cbef1b65399065c2de2c495971e90466ff38f2d000000000000000000000001e541FD749419CA806a8bc7da8ac23D346f2dF8B77062a2b0eea575f659a1aaf18c1df5d93e0528245",
            address(0x062a2B0eeA575f659a1aaf18c1DF5D93E0528245),
            2
        );

        uint16 closureId = 6;
        uint256 bgtPercentX256 = 0;
        uint256[MAX_TOKENS] memory amountLimits;
        opener.mint(
            diamond,
            inputToken,
            2e8,
            params,
            closureId,
            bgtPercentX256,
            amountLimits,
            0
        );
    }

    function testThreeTokenOpener() public forkOnly {
        opener = deployOpenerDeterministically();
        console2.log("opener address", address(opener));

        // note these inputs and params info must be generated by the swap.mjs file.
        address inputToken = address(
            0x0555E30da8f98308EdB960aa94C0Db47230d2B9c
        );
        uint256 inputAmount = 100000000;
        address outputToken = address(
            0x541FD749419CA806a8bc7da8ac23D346f2dF8B77
        );
        uint256 outputQuote = 999949888810858131;
        uint256 outputMin = 989950389922749549;
        address outputReceiver = address(
            0xed63E871F5de87cb1919671eE9e2d331183Eda8f
        );

        deal(inputToken, address(this), 5e18);
        IERC20(inputToken).approve(address(opener), 5e18);

        IOBRouter.swapTokenInfo memory info = IOBRouter.swapTokenInfo({
            inputToken: inputToken,
            inputAmount: inputAmount,
            outputToken: outputToken,
            outputQuote: outputQuote,
            outputMin: outputMin,
            outputReceiver: outputReceiver
        });

        bytes[MAX_TOKENS] memory params;
        params[1] = abi.encodeWithSelector(
            IOBRouter.swap.selector,
            info,
            hex"541FD749419CA806a8bc7da8ac23D346f2dF8B77010000000000000000000000000000000000000000000000000ddfee63c4c6e4b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db58ce5b56bc800010555E30da8f98308EdB960aa94C0Db47230d2B9c01ffff09BE09E71BDc7b8a50A05F7291920590505e3C7744cbef1b65399065c2de2c495971e90466ff38f2d000000000000000000000001e541FD749419CA806a8bc7da8ac23D346f2dF8B77062a2b0eea575f659a1aaf18c1df5d93e0528245",
            address(0x062a2B0eeA575f659a1aaf18c1DF5D93E0528245),
            2
        );

        // second swap we need to make, also needs to be generated
        inputToken = address(0x0555E30da8f98308EdB960aa94C0Db47230d2B9c);
        inputAmount = 100000000;
        outputToken = address(0x657e8C867D8B37dCC18fA4Caead9C45EB088C642);
        outputQuote = 100256659;
        outputMin = 99254092;
        outputReceiver = address(0xed63E871F5de87cb1919671eE9e2d331183Eda8f);
        info = IOBRouter.swapTokenInfo({
            inputToken: inputToken,
            inputAmount: inputAmount,
            outputToken: outputToken,
            outputQuote: outputQuote,
            outputMin: outputMin,
            outputReceiver: outputReceiver
        });

        params[0] = abi.encodeWithSelector(
            IOBRouter.swap.selector,
            info,
            hex"657e8C867D8B37dCC18fA4Caead9C45EB088C642000000000000000000000000000000000000000000000000000000000005f9cb9300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f9cb92010555E30da8f98308EdB960aa94C0Db47230d2B9c01ffff0102eEb6eDC9f0D9b19742266fD7A462126751071001062a2b0eea575f659a1aaf18c1df5d93e0528245",
            address(0x062a2B0eeA575f659a1aaf18c1DF5D93E0528245),
            2
        );

        uint16 closureId = 7;
        uint256 bgtPercentX256 = 0;
        uint256[MAX_TOKENS] memory amountLimits;
        opener.mint(
            diamond,
            inputToken,
            3e8,
            params,
            closureId,
            bgtPercentX256,
            amountLimits,
            0
        );
    }
}
